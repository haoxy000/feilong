#!/bin/bash
###############################################################################
# Copyright 2017, 2022 IBM Corporation
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
###############################################################################
# COMPONENT: zthinshellutils                                                   #
#                                                                             #
# Sourceable functions for Bash scripts in xCAT.                              #
###############################################################################
# Pick up our configuration settings:
source /var/opt/zthin/settings.conf

export PATH=/opt/zthin/bin:$PATH

###############################################################################
### CAPTURE COMMAND-LINE ARGUMENTS AS AN ARRAY ################################
###############################################################################

i=0
for arg in "$@"; do
  args[$i]=$arg
  i=$(($i+1))
done

###############################################################################
### ARGUMENT-HANDLING VARIABLES ###############################################
###############################################################################

expectedShortOptions=''
expectedLongOptions=''
expectedNamedArguments=''
namedArgListing=''
positionalArgListing=''
optionHelp='OPTIONS:'

###############################################################################
### ENVIRONMENT AND COMPATIBILITY CHECKS ######################################
###############################################################################

# Make sure VMCP is available and loaded. It's possible vmcp didn't load
# becuase it was built into the kernel rather than as a loadable module, so
# we also (if attempting to load the vmcp module fails) check whether the
# vmcp command works for us before deciding we have a problem here.

# Compatibility mode to deal with inconsistencies between how BASH 3.2.x and
# 3.1.x handle regular expressions (and possibly other syntax issues).
[[ ! $(bash --version |
       head -1 |
       sed 's/.*version \([^(]*\).*/\1/') < 3.2 ]] && shopt -s compat31

###############################################################################
### GLOBAL VARIABLES ##########################################################
###############################################################################

CMDNAME=$(basename $0)

###############################################################################
### CONSTANTS #################################################################
###############################################################################

blockSize=512


###############################################################################
### ARGUMENT-HANDLING FUNCTIONS ###############################################
###############################################################################

function isOption {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Indicates whether the specified option was given on the command line.
  #   Also records the option being checked for as part of a list of "expected"
  #   options which can be used to check for "unexpected" options.
  # @Returns:
  #   0 if the specified option was given on the command line
  #   1 otherwise.
  # @Parameters:
  local short=$1
  local long=$2
  local helpText=$3
  # @Code:
  helpText=$(echo "$helpText" | sed 's/\(\S\)\s\s*/\1 /g')
  if [[ $short =~ ^- ]]; then
    expectedShortOptions="${expectedShortOptions}${short#-}"
    if [[ $long =~ ^-- ]]; then
      expectedLongOptions="${expectedLongOptions} ${long#--}"
      optionHelp=$(echo -e "${optionHelp}\n  ${short}/${long}: ${helpText}")
    else
      optionHelp=$(echo -e "${optionHelp}\n  ${short}: ${helpText}")
    fi
  else
    if [[ $long =~ ^-- ]]; then
      expectedLongOptions="${expectedLongOptions} ${long#--}"
      optionHelp=$(echo -e "${optionHelp}\n     ${long}: ${helpText}")
    fi
  fi
  for arg in ${args[@]}; do
    if [[ $long =~ ^-- ]]; then
      if [[ $arg = $long ]]; then
        return 0
      fi
    fi
    if [[ $short =~ ^- ]]; then
      if [[ $arg =~ ^- && ! $arg =~ ^-- ]]; then
        if [[ ${arg#-} =~ ${short#-} ]]; then
          return 0
        fi
      fi
    fi
  done
  return 1
} #isOption{}






###############################################################################
### HELP FUNCTIONS ############################################################
###############################################################################

function printCMDUsage {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Prints usage help text using a list generated by previous requests made
  #   to parse the command-line argument list.
  # @Code:
  echo -n "USAGE: $CMDNAME [OPTIONS]"
  [[ $namedArgListing ]] && echo -n " ${namedArgListing}" |
                            sed 's/\[--/ \\\n       '"${CMDNAME//?/ }"' [--/g'
  if [[ $positionalArgListing ]]; then
    echo " ${positionalArgListing}" |
      sed 's/ / \\\n       '"${CMDNAME//?/ }"' /g'
  else
    echo ''
  fi
  echo "${optionHelp}"
} #printCMDUsage{}

###############################################################################

function printCMDDescription {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   This function is not intended to be actually called, but it will serve as
  #   a fall-back in the event that an override is not provided in the script
  #   making use of this library.
  # @Code:
  echo 'No description available.'
} #printCMDDescription{}

###############################################################################

function printCMDExamples {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   This function is not intended to be actually called, but it will serve as
  #   a fall-back in the event that an override is not provided in the script
  #   making use of this library.
  # @Code:
} #printCMDDescription{}

###############################################################################

function printCMDNotes {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   This function is not intended to be actually called, but it will serve as
  #   a fall-back in the event that an override is not provided in the script
  #   making use of this library.
  # @Code:
} #printCMDNodes{}

###############################################################################

function printHelp {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Prints full help with auto-generated usage text and an overridable
  #   command description, examples, and notes.
  # @See:
  #   printCMDDescription{}
  #   printCMDExamples{}
  #   printCMDNotes{}
  # @Code:
  printCMDDescription
  printCMDUsage    | sed -r 's/(^\S.*$)/\n\1/'
  printCMDExamples | sed -r 's/(^\S.*$)/\n\1/'
  printCMDNotes    | sed -r 's/(^\S.*$)/\n\1/'
} #printHelp{}

###############################################################################
### OUTPUT AND LOGGING FUNCTIONS ##############################################
###############################################################################

function inform {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Prints and logs informational text.
  # @Parameters:
  local message=$1
  # @Code:
  message=$(echo "$message" | sed 's/\(\S\)\s\s*/\1 /g')
  fullmsg="$$.0 $CMDNAME: ${BASH_SOURCE[1]/*\/}: ${FUNCNAME[1]}: ${message}"
  size=${#fullmsg}
  logger -p 'local5.info' --size $size "$fullmsg"
  echo "${message}"
} #inform{}

###############################################################################

function warn {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Prints and logs warning text. 'WARNING: ' is prepended to the specified
  #   text when printing it to the console.
  # @Parameters:
  local message=$1
  # @Code:
  message=$(echo "$message" | sed 's/\s\s*/ /g')
  fullmsg="$$.0 $CMDNAME: ${BASH_SOURCE[1]/*\/}: ${FUNCNAME[1]}: ${message}"
  size=${#fullmsg}
  logger -p 'local5.warning' --size $size "$fullmsg"
  echo "WARNING: ${message}"
} #warn{}

###############################################################################

function printError {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Prints and logs error text. 'ERROR: ' is prepended to the specified
  #   text when printing it to the console.
  # @Parameters:
  local message=$1
  # @Code:
  message=$(echo "$message" | sed 's/\s\s*/ /g')
  fullmsg="$$.0 $CMDNAME: ${BASH_SOURCE[1]/*\/}: ${FUNCNAME[1]}: ${message}"
  size=${#fullmsg}
  logger -p 'local5.err' --size $size "$fullmsg"
  echo "ERROR: ${message}"
} #printError{}

###############################################################################

function getStageFailures {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Gets a list of the pipe stages that are failing and their return code.
  # @Parameters:
  declare -a stageNames=("${!1}")
  declare -a stageRC=("${!2}")
  # @Code:
  getStageFailuresOut=""
  for (( i=1; i<${#stageRC[@]}; i++ ))
  do
    if (( ${stageRC[i]} == 0 )); then
      continue
    else
      if [ -n "$getStageFailuresOut" ]; then
        getStageFailuresOut="$getStageFailuresOut, ${stageNames[i]}("${stageRC[i]}")"
      else
        getStageFailuresOut="${stageNames[i]}("${stageRC[i]}")"
      fi
    fi
  done
} #getStageFailures{}

###############################################################################
### DISK HANDLING FUNCTIONS ###################################################
###############################################################################

function findLinuxDeviceNode {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Locates the Linux device node associated with the specified virtual
  #   device address.
  # @Parameters:
  local vdev=$1
  # @Code:
  grep -i 0.0.$vdev /proc/dasd/devices | sed 's/.*is\s\(\S*\)\s.*/\/dev\/\1/'
} #findLinuxDeviceNode{}

###############################################################################

function chccwdevDevice {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  # Issue chccwdev to online or offline a device.
  # @Parameters:
  local device=$1              # device address
  local turnOn=$2              # 1 = online device, 0 = offline device
  # @Returns:
  #   0 - chccwdev was successful
  #   1 - Invalid online/offline operand
  #   4 - chccwdev failed
  # @Code:
  local opt
  local englishOpt
  local retCode=0
  local sleepTimes

  # Handle parms
  if [[ $turnOn == "online" ]]; then
    opt="-e"
    # Sleep total about 2:30 minutes.  If it takes more than that it is better
    # to fail the connect.
    sleepTimes=".001 .01 .1 .5 1 2 3 5 8 15 22 34 60"
  elif [[ "$turnOn" == "offline" ]]; then
    opt="-d"
    # Total about 10 minutes to allow for worst case scenario during offline.
    # This gives disconnect functions the best chance to ensure that
    # Linux is cleaned up and avoid future problems.
    sleepTimes=".001 .01 .1 .5 1 2 3 5 8 15 22 34 60 60 60 60 60 90 120"
  else
    return 1
  fi
  englishOpt=$turnOn

  output=$(chccwdev $opt $device 2>&1)
  local rc=$?
  res=$(echo $output|grep "not found")
  if [[ ($rc -ne 0) && $res ]]; then
    inform "Attempt to set device $device $englishOpt: device $device not found."
    return 1
  fi

  if [[ $rc -ne 0 ]]; then
    inform "Attempt to set device $englishOpt failed and return code is $rc. Retrying..." 1>&2
    # retry, while waiting various durations
    for seconds in $sleepTimes; do
      sleep $seconds
      chccwdev $opt $device > /dev/null 2>&1
      rc=$?
      if [[ $rc -eq 0 ]]; then
        break # successful - leave loop
      fi

    done

    # Set subroutine return code if chccwdev attempts failed
    if [[ $rc -ne 0 ]]; then
      warn "Error setting device $device $englishOpt: $retCode"
      local retCode=1
    else
      inform "set device $device $englishOpt successfully."
    fi
  else
    inform "set device $device $englishOpt successfully."
  fi

  # Settle udev whether or not the change was successful
  which udevadm &> /dev/null && udevadm settle || udevsettle

  return $retCode
} #onOrOffDevice{}




###############################################################################

function addLun {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   add the scsi disk to the specified fcp and wwpn path
  # @Parameters:
  local fcpChannel=$1       # FCP device channel to connect to disk.
  local wwpn=$2             # World wide port number.
  local lun=$3              # Logical unit number.
  overall_rc=0

  # Attach the disk
  if [[ ! -d /sys/bus/ccw/devices/0.0.${fcpChannel}/${wwpn}/${lun} ]]; then
      echo "${lun}" > /sys/bus/ccw/devices/0.0.${fcpChannel}/${wwpn}/unit_add
  fi
  rc=$?
  if [[ $rc -ne 0 ]]; then
      printError "An error was encountered while unit_add the disk. rc is $rc."
  fi

  # Wait 30s in total until disk shows up 
  for i in 0.1 0.2 0.2 0.5 1 1 1 2 2 2 5 5 10
  do
      if [[ -b /dev/disk/by-path/ccw-0.0.${fcpChannel}-zfcp-${wwpn}:${lun} ]]; then
          break
      fi
      sleep $i
  done

  if [[ ! -b /dev/disk/by-path/ccw-0.0.${fcpChannel}-zfcp-${wwpn}:${lun} ]]; then
      printError "The lun ${lun} does not show up on fcp:${fcpChannel} and wwpn: ${wwpn}."
      overall_rc=1
  fi

  return $overall_rc
}





###############################################################################

function getDiskAlias {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   Prints the alias virtual device address used on this system for the
  #   connected disk with the specified virtual device address on the system
  #   being captured/deployed.  NOTE: It is expected that there is only one
  #   active link to a target virtual machines disk.  Multiple capture/deploy
  #   working on the same target disk is not supported.
  # @Parameters:
  local userID=$1
  local vdev=$2
  # @Code:
  # The "tail -1" here is used as a robustness measure to avoid running into
  # problems if a previous failed disconnect lead to an admin manually cleaning
  # up disk links, but not the list of current linking aliases.
  grep "^${userID} ${vdev}" $currentDiskAliases |
    sed 's/.*AS //' |
    tail -1
} #getDiskAlias{}

###############################################################################
function removeLun {
  : SOURCE: ${BASH_SOURCE}
  : STACK:  ${FUNCNAME[@]}
  # @Description:
  #   remove the lun from the specified fcp, wwpn path
  # @Parameters:
  local fcpChannel=$1       # FCP device channel to connect to disk.
  local wwpn=$2             # World wide port number.
  local lun=$3              # Logical unit number.
  local rc=0

  if [[ -d /sys/bus/ccw/devices/0.0.${fcpChannel}/${wwpn}/${lun} ]]; then
    local unit_remove_missing=1
    local lun_missing=1
    local i

    # Remove the SCSI device
    local devName=`ls -al /dev/disk/by-path/ccw-0.0.${fcpChannel}-zfcp-${wwpn}:${lun} | tr '/' ' ' | awk '{print \$NF}'`
    if [[ "$devName" != "" && -e "/sys/block/$devName/device/delete" ]]; then
        echo 1 > "/sys/block/$devName/device/delete"
    fi

    # Remove the lun device
    for i in 1 1 1 2 5 5 5 10 10 10 10
    do
        if [[ -e "/sys/bus/ccw/devices/0.0.${fcpChannel}/${wwpn}/unit_remove" ]]; then
            unit_remove_missing=0
            echo $lun > "/sys/bus/ccw/devices/0.0.${fcpChannel}/${wwpn}/unit_remove"
            if [[ $? -eq 0 ]]; then
                lun_missing=0
                break;
            fi
        fi
        sleep $i
    done

    if [[ $lun_missing -eq 1 ]]; then
        printError "An error was encountered while writing to the unit_remove file."
        rc=5
    fi
    if [[ $unit_remove_missing -eq 1 ]]; then
        printError "An error was encountered while detaching the disk.  \
          /sys/bus/ccw/devices/0.0.${fcpChannel}/${wwpn}/unit_remove \
          does not exist."
        rc=7
    fi
  fi
  return $rc
}







